// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.19;
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import { TransferHelper } from "./libraries/TransferHelper.sol";

contract DiceGame is Ownable {
    using TransferHelper for address;

    struct GameRound {
        bool fulfilled; // whether the request has been successfully fulfilled
        address user;
        uint256 totalBet;
        uint256 totalWinnings;
        uint256[] betAmts;
        uint256[] diceRollResult;
    }
    uint256 public constant BANANA_POINTS_PREMINT = 1_000_000 ether;
    uint256 public constant WIN69_MULTIPLIER = 10;
    uint256 public constant CALLBACK_GAS = 200_000;
    uint256 public constant MAX_OPERATOR_GAS = 1_000_000;
    uint256 public constant MAX_NUM_WORDS = 3;
    uint256 public constant DELIMITER = 1e18;
    uint8 public constant decimals = 18;

    string public constant name = "Banana Points";
    string public constant symbol = "BPT";

    uint256 public rollOperatorGas = 700_000;
    uint256 public immutable gamePeriod;
    address public coin;
    address public immutable V3Deployer;
    address public wrappedNative;
    address public immutable gameRngWallet;
    address public immutable rollOperator;
    address public faucet;

    /// @notice Timestamp when the geme ower
    uint256 public endTime;
    /// @notice Initial rate of tokens per coin
    uint256 public initialTokenRate;

    uint256 public gameId;
    uint256 public lastFulfilledGameId;

    // The total supply of points in existence
    uint256 public totalSupply;
    // Maps an address to their current balance
    mapping(address => uint256) private userBalances;
    // Maps a game ID to its round information
    mapping(uint256 => GameRound) private gameRounds; /* gameId --> GameRound */
    // Maps an address to their game IDs
    mapping(address => uint256[]) public userGameIds;

    address[] oldFaucets;

    constructor(
        address _gameRngWalletAddress,
        uint _gamePeriod,
        address _V3Deployer,
        address _rollOperator
    ) {
        gameRngWallet = _gameRngWalletAddress;
        if (_gameRngWalletAddress == address(0) || _V3Deployer == address(0)) revert ZeroValue();
        if (_gamePeriod < 2 hours || _gamePeriod > 180 days) revert GamePeriod();
        gamePeriod = _gamePeriod;
        rollOperator = _rollOperator;
        V3Deployer = _V3Deployer;
        transferOwnership(_V3Deployer);
    }

    event Transfer(address to, uint256 value);
    event MintPoints(address recipient, uint256 pointsAmount);
    event BurnPoints(address from, uint256 pointsAmount);
    event Redeem(address user, uint256 amount);
    event PurchasePoints(address user, uint256 paymentAmount);
    event Bet(uint256 gameId, address user, uint256 totalBetAmt);
    event BetFailed(address user);
    event ClaimAirDrop(address user, uint256 amount);

    error AmountOfEthSentIsTooSmall(uint256 sent, uint256 minimum);
    error InvalidGameId(uint256 id);
    error InvalidLength();
    error InvaliddiceRollResult(uint256 id);
    error GamePeriod();
    error ZeroValue();
    error NotEnoughCoinBalance(uint256 want, uint256 have);
    error Forbidden();

    // Modifiers
    modifier shouldGameIsNotOver() {
        require(gameNotOver(), "game over");
        _;
    }

    modifier shouldGameIsOver() {
        require(gameOver(), "game is NOT over");
        _;
    }

    /// @notice Receive ETH and forward to `sponsorWallet`.
    receive() external payable {
        (bool success, ) = gameRngWallet.call{ value: msg.value }("");
        require(success);
    }

    /**
     * @notice Starts a new game with specific parameters, initial token rate, etc.
     * non-zero initial token rate, and game not already started (initialTokenRate == 0).
     * @param _initialTokenRate The initial rate used within the game logic, set at the start and never changed afterward.
     * @param _coin address of Coin token for this Game
     * @custom:modifier onlyOwner Restricts the function's execution to the contract's owner.
     */
    function startGame(
        uint _initialTokenRate,
        address _coin,
        address _wrappedNative,
        address _faucet
    ) external payable onlyOwner {
        // Ensure the initial token rate is not already set
        require(initialTokenRate == 0, "o-o");
        if (_coin == address(0) || _faucet == address(0)) revert ZeroValue();
        // Initialize the initial token rate and calculate the end time based on the current timestamp
        initialTokenRate = _initialTokenRate;
        coin = _coin;
        wrappedNative = _wrappedNative;
        endTime = block.timestamp + gamePeriod;
        if (msg.value > 0) {
            (bool success, ) = gameRngWallet.call{ value: msg.value }("");
            require(success);
        }
        faucet = _faucet;
        _mintPoints(_faucet, BANANA_POINTS_PREMINT);
    }

    /// @notice Retrieves the balance of a given account
    /// @dev Returns the current balance stored in `userBalances`
    /// @param account The address of the user whose balance we want to retrieve
    /// @return The balance of the user
    function balanceOf(address account) public view returns (uint256) {
        return userBalances[account];
    }

    /// @notice Retrieves info of particular game id
    /// @param _gameId game number/id
    /// @return gameInfo GameRound struct
    function getGameRoundInfo(uint256 _gameId) public view returns (GameRound memory gameInfo) {
        gameInfo = gameRounds[_gameId];
    }

    /// @notice Retrieves the list of game IDs associated with a given user
    /// @dev Fetches the array of game IDs from `userGameIds` using `.values()`
    /// @param user The address of the user whose game IDs we want to retrieve
    /// @return ids An array of game IDs that the user participated in
    function getUserGameIds(address user) public view returns (uint256[] memory ids) {
        ids = userGameIds[user];
    }

    /// @notice Retrieves the number of games a user has participated in
    /// @dev Calculates the length of the user's game IDs set
    /// @param user The address of the user whose number of games we want to know
    /// @return num The number of games the user has participated in
    function getUserGamesNumber(address user) public view returns (uint256 num) {
        num = userGameIds[user].length;
    }

    // @notice Retrieves the last game information for a given user
    /// @dev Fetches the last game ID and corresponding round info from `userGameIds` and `gameRounds`
    /// @param user The address of the user whose last game information we want to retrieve
    /// @return id The ID of the last game the user participated in
    /// @return round The GameRound struct containing the details of the game round
    function getUserLastGameInfo(
        address user
    ) public view returns (uint256 id, GameRound memory round) {
        uint256 length = userGameIds[user].length;
        if (length > 0) {
            id = userGameIds[user][length - 1];
            round = gameRounds[id];
        }
    }

    /// @notice Determines whether the game is still ongoing or not
    /// @dev Compares the current block timestamp against `endTime`; also ensures that the game has started by requiring `_endTime` to be non-zero
    /// @return Whether the current time is before the game's end time (`true`) or after (`false`)
    function gameNotOver() public view returns (bool) {
        uint256 _endTime = endTime;
        _checkZero(_endTime);
        return block.timestamp < _endTime;
    }

    /**
     * @notice Checks if the game has been concluded based on the time limit.
     * @dev Returns true if the current block timestamp exceeds the end time of the game by 10 minutes.
     *      This implies a grace period of 10 minutes after the official end time before declaring the game over.
     *      The function requires that `endTime` is set and the game has started, otherwise it reverts with an error message.
     *
     * @return A boolean value indicating whether the game is over (true) or not (false).
     */
    function gameOver() public view returns (bool) {
        uint256 _endTime = endTime;
        _checkZero(_endTime);
        return (block.timestamp > _endTime && gameId == lastFulfilledGameId);
    }

    struct GameState {
        uint256 gameId;
        uint256 betNumber;
    }

    /// @dev This function returns the state of games that have not yet been fulfilled.
    /// It constructs an array of `GameState` structures representing each unfulfilled game's
    /// ID and the count of bets placed in that game round.
    /// The function only includes games with IDs greater than `lastFulfilledGameId`.
    /// @return state An array of `GameState` structs for each unfulfilled game.
    function getGameState() public view returns (GameState[] memory state) {
        if (gameId > lastFulfilledGameId) {
            uint256 requests = gameId - lastFulfilledGameId;
            state = new GameState[](requests);
            uint256 index;
            while (lastFulfilledGameId + index < gameId) {
                uint256 id = lastFulfilledGameId + index + 1;
                state[index].gameId = id;
                state[index].betNumber = gameRounds[id].betAmts.length;
                index++;
            }
        }
    }

    /// @notice Allows a user to place a bet on a dice roll(s), record the bet details, and request randomness
    /// @dev Transfers the required ETH to sponsor wallet and creates a new game round with provided bets
    /// @param _betAmts An array of amounts representing individual bets for each roll of the dice
    function bet(uint256[] memory _betAmts) external payable shouldGameIsNotOver {
        // user must send enough native for the callback
        // otherwise the transaction will fail
        uint256 minimumSend = tx.gasprice * CALLBACK_GAS;
        _checkAmount(minimumSend);
        // Transfer the received native to the gameRngWallet wallet to cover the callback transaction costs
        (bool success, ) = gameRngWallet.call{ value: msg.value }("");
        require(success);
        _bet(msg.sender, _betAmts);
    }

    struct OperatorInput {
        address user;
        uint256[] betAmts;
    }
    /// @notice Allows roll operator to place batch bets for different users. Operator must add users to batch who
    ///     have enough wrapped native tokens, have given approval for it, and have fulfilled their last game round
    /// @param _inputs encoded input for array of OperatorInput structs
    function bet(bytes calldata _inputs) external payable shouldGameIsNotOver {
        if (msg.sender != rollOperator) revert();
        OperatorInput[] memory batchInfo = abi.decode(_inputs, (OperatorInput[]));
        uint length = batchInfo.length;
        if (length == 0 || length > 30) revert InvalidLength();
        uint256 minimumSend = tx.gasprice * CALLBACK_GAS * length;
        uint256 gasAmt = tx.gasprice * rollOperatorGas;
        _checkAmount(minimumSend);
        OperatorInput memory info;
        uint successCount;
        for (uint i; i < length; ) {
            info = batchInfo[i];
            try this.processBatchBet(info.user, info.betAmts) {
                unchecked {
                    ++successCount;
                }
            } catch {
                emit BetFailed(info.user);
            }
            unchecked {
                ++i;
            }
        }

        uint refund;
        if (successCount > 0) {
            uint gasRandomizer = (msg.value * successCount) / length;
            refund = msg.value - gasRandomizer;
            (bool success, ) = gameRngWallet.call{ value: gasRandomizer }("");
            require(success);
            (bool result, ) = wrappedNative.call(
                abi.encodeWithSignature(
                    "withdrawTo(address,uint256)",
                    msg.sender,
                    gasAmt * successCount
                )
            );
            require(result, "withdrawTo");
        } else {
            refund = msg.value;
        }
        if (refund > 0) {
            (bool success, ) = msg.sender.call{ value: refund }("");
            require(success);
        }
    }

    function processBatchBet(address _user, uint[] memory _betAmts) external shouldGameIsNotOver {
        if (tx.origin != rollOperator) revert();
        uint gasAmt;
        unchecked {
            gasAmt = tx.gasprice * rollOperatorGas;
        }
        wrappedNative.safeTransferFrom(_user, address(this), gasAmt);
        _bet(_user, _betAmts);
    }

    /// @notice Allows roll operator place bets for users
    /// @param _user Address of certain user
    /// @param _betAmts An array of amounts representing individual bets for each roll of the dice
    function bet(address _user, uint256[] memory _betAmts) external payable shouldGameIsNotOver {
        if (msg.sender != rollOperator) revert();
        // msg.value must be enough to cover randomizer gas spends
        uint256 minimumSend = tx.gasprice * CALLBACK_GAS;
        // take from user gas amount*gas.price
        uint256 gasAmt = tx.gasprice * rollOperatorGas;
        _checkAmount(minimumSend);
        wrappedNative.safeTransferFrom(_user, address(this), gasAmt);
        (bool success, ) = wrappedNative.call(
            abi.encodeWithSignature("withdrawTo(address,uint256)", msg.sender, gasAmt)
        );
        require(success, "withdrawTo");
        // send to randomizer 200_000gas*gas.price for callback
        (bool result, ) = gameRngWallet.call{ value: msg.value }("");
        require(result);
        _bet(_user, _betAmts);
    }

    function _bet(address _user, uint256[] memory betAmts) internal {
        (uint256 id, GameRound memory round) = getUserLastGameInfo(_user);
        require(round.fulfilled || id == 0, "last round not fulfilled");
        // Check if the number of dice rolls is within the permitted range
        uint256 numWords = betAmts.length;
        require(numWords > 0 && numWords <= MAX_NUM_WORDS, "invalid betAmts");
        // Calculate the total bet amount from the array of bets
        uint256 totalBetAmt;
        for (uint i; i < numWords; ) {
            // Each bet amount must be greater than zero
            _checkZero(betAmts[i]);
            totalBetAmt += betAmts[i];
            unchecked {
                ++i;
            }
        }
        // Ensure the user has enough points to cover their total bet
        // It is possible to resend a bid for the same balance,
        // so this check is also added to the callback function
        require(totalBetAmt <= balanceOf(_user), "points are not enough");
        _burnPoints(_user, totalBetAmt);

        unchecked {
            ++gameId;
        }
        uint256 _gameId = gameId;

        // Record the game round details in the contract state
        gameRounds[_gameId] = GameRound({
            fulfilled: false,
            user: _user,
            totalBet: totalBetAmt,
            totalWinnings: 0,
            betAmts: betAmts,
            diceRollResult: new uint256[](betAmts.length)
        });

        // Associate the game ID with the user's address
        userGameIds[_user].push(_gameId);
        emit Bet(_gameId, _user, totalBetAmt);
    }

    struct RandomData {
        uint256 id;
        uint256[] rn;
    }

    /**
     * @notice Fulfills the generation of random words if gas requirement is met
     * @dev Processes each `RandomData` entries until either all are processed or minimum remaining gas is not met
     * @param minRemainingGas The minimum amount of gas that must be left for the function to continue processing
     * @param randomData An array of `RandomData` structs containing the IDs and random number arrays to process
     * Requirements:
     * - Only callable by the `gameRngWallet`.
     * - Will stop processing if the remaining gas is less than `minRemainingGas`.
     * Emits a `RandomWordsFulfilled` event upon successful processing of an entry.
     * Uses the `_fulfillRandomWords` internal function to process each entry.
     */
    function fulfillRandomWords(uint256 minRemainingGas, RandomData[] memory randomData) external {
        require(msg.sender == gameRngWallet, "invalid caller");
        for (uint256 i; i < randomData.length; ) {
            if (gasleft() < minRemainingGas) {
                break;
            }
            _fulfillRandomWords(randomData[i].id, randomData[i].rn);
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Records the result of dice rolls, updates the game round, and handles payouts
    /// @dev Only callable by the `gameRngWallet`. Checks if the round can be fulfilled
    /// @param _gameId The unique identifier of the game round that the dice roll results correspond to
    /// @param _randomWords The array of random numbers provided by off-chain gameRngWallet service
    /// Using the gameRngWallet service is free, meaning there is no subscription fee to pay.
    /// There is a gas cost incurred on-chain when gameRngWallet places the random number on-chain in response to a request,
    /// which the requester needs to pay for.
    function _fulfillRandomWords(uint256 _gameId, uint256[] memory _randomWords) private {
        unchecked {
            ++lastFulfilledGameId;
        }
        // Retrieve the game round using the _gameId
        GameRound storage round = gameRounds[_gameId];
        uint256 totalBet = round.totalBet;
        if (_gameId != lastFulfilledGameId || totalBet == 0) {
            revert InvalidGameId(_gameId);
        }

        uint256 length = _randomWords.length;
        if (length != round.diceRollResult.length) {
            revert InvaliddiceRollResult(_gameId);
        }
        // Mark the round as fulfilled
        round.fulfilled = true;
        uint256 totalWinnings;

        uint256 bitDice;
        bool double3;
        for (uint i; i < length; ) {
            // Get the dice number between 1 and 6
            uint256 num = (_randomWords[i] % 6) + 1;
            // Calculate winnings based on even dice numbers
            if (num % 2 == 0) {
                totalWinnings += round.betAmts[i] * 2;
            }
            // Special logic for determining 33
            if (num == 3 && !double3 && bitDice & (1 << num) == (1 << num)) {
                double3 = true;
            }
            bitDice |= (1 << num);
            round.diceRollResult[i] = num;
            unchecked {
                ++i;
            }
        }
        // Special logic for determining winnings if the special 69 condition is met
        // or if the special 666 condition is met
        // or if the special repdigit condition is met
        if (length == 3) {
            //Repdigit
            if ((bitDice & (bitDice - 1)) == 0) {
                totalWinnings = 0;
                if (bitDice == 64) {
                    // 666
                    uint256 balance = balanceOf(round.user);
                    if (balance > 0) {
                        _burnPoints(round.user, balance);
                    }
                }
            } else if ((bitDice == 72 && !double3) || bitDice == 112) {
                // 69
                totalWinnings = totalBet * WIN69_MULTIPLIER;
            }
        }
        if (totalWinnings > 0) {
            round.totalWinnings = totalWinnings;
            _mintPoints(round.user, totalWinnings);
        }
    }

    /**
     * @notice Allows users to purchase a specified amount of points.
     * @param desiredAmountOut The exact amount of points the user wants to purchase.
     */
    function purchasePoints(uint256 desiredAmountOut) external shouldGameIsNotOver {
        uint256 paymentAmount = calculatePaymentAmount(desiredAmountOut);
        coin.safeTransferFrom(msg.sender, address(this), paymentAmount);
        _checkZero(desiredAmountOut);
        _mintPoints(msg.sender, desiredAmountOut);
        emit PurchasePoints(msg.sender, paymentAmount);
    }

    /**
     * @notice Calculates the payment amount required for purchasing a specific amount of points.
     * @param desiredPointsAmount The desired amount of points.
     * @return paymentAmount The corresponding amount of payment currency that can be purchased/sold for the specified points.
     */
    function calculatePaymentAmount(
        uint256 desiredPointsAmount
    ) public view returns (uint256 paymentAmount) {
        uint256 tokenRate = initialTokenRate;
        if (tokenRate == 0) revert ZeroValue();
        uint256 intermediate = desiredPointsAmount * DELIMITER;
        paymentAmount = intermediate / tokenRate;
        // Round up only for buying
        if (paymentAmount == 0 || intermediate % tokenRate > 0) {
            paymentAmount += 1;
        }
    }

    /**
     * @notice Calculates the points amount a user receives for a given coin amount.
     * @param paymentAmount Amount of the payment currency (e.g., ETH) used to purchase tokens.
     * @return pointsAmount The resulting amount of tokens that can be purchased for the specified `paymentAmount`.
     */
    function calculatePointsAmount(
        uint256 paymentAmount
    ) public view returns (uint256 pointsAmount) {
        uint256 rate = initialTokenRate;
        if (rate == 0) revert ZeroValue();
        pointsAmount = (paymentAmount * rate) / DELIMITER;
    }

    function sendLiquidity() external shouldGameIsOver onlyOwner returns (uint amount) {
        amount = coin.getBalance();
        coin.safeTransfer(V3Deployer, amount);
    }

    function setOperatorGas(uint256 _operatorGas) external onlyOwner {
        _checkZero(_operatorGas);
        if (_operatorGas > MAX_OPERATOR_GAS) revert();
        rollOperatorGas = _operatorGas;
    }

    function setFaucet(address _faucet) external onlyOwner {
        oldFaucets.push(faucet);
        faucet = _faucet;
    }

    function mint(address to, uint256 amount) external onlyOwner {
        _checkZero(amount);
        userBalances[to] += amount;
        totalSupply += amount;
        emit MintPoints(to, amount);
    }
    function transfer(address to, uint256 amount) external shouldGameIsNotOver returns (bool) {
        if (msg.sender != faucet) revert Forbidden();
        if (to == address(0)) revert ZeroValue();
        uint256 fromBalance = userBalances[msg.sender];
        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
        unchecked {
            userBalances[msg.sender] = fromBalance - amount;
            userBalances[to] += amount;
        }
        emit Transfer(to, amount);
        return true;
    }

    function getOldFaucets() external view returns (address[] memory _oldFaucets) {
        _oldFaucets = oldFaucets;
    }

    /// @notice Redeem points for tokens.
    /// @dev Burns points from the redeemer's balance and mints equivalent tokens.
    ///      Emits a Redeem event upon success.
    ///      Requires the game to be over.
    ///      Requires the Token to have been set and the caller to have a non-zero point balance.
    /// @param signature 65 bytes signature for verify eligibility redeem tokens
    /// @param voteFor Vote option (must be 1, 2, or 3)
    function redeem(bytes calldata signature, uint voteFor) external shouldGameIsOver {
        require(voteFor > 0 && voteFor < 4, "vote must be 1, 2 or 3");
        _checkSignature(signature, voteFor);
        uint256 amount = balanceOf(msg.sender);
        _checkZero(amount);
        _burnPoints(msg.sender, amount);
        (bool success, ) = V3Deployer.call(
            abi.encodeWithSignature("redeem(address,uint256,uint256)", msg.sender, amount, voteFor)
        );
        require(success);
        emit Redeem(msg.sender, amount);
    }

    function _checkSignature(bytes calldata signature, uint voteFor) private view {
        bytes32 message = _withPrefix(
            keccak256(abi.encodePacked(msg.sender, block.chainid, address(this), voteFor))
        );
        require(ECDSA.recover(message, signature) == rollOperator, "invalid signature!");
    }

    function _withPrefix(bytes32 _hash) private pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", _hash));
    }

    /// @notice Mints points and assigns them to a specified account
    /// @dev Increments `userBalances` and `totalSupply` by the given `amount`
    /// @param to The address of the recipient to whom points are to be minted
    /// @param amount The quantity of points to be minted
    function _mintPoints(address to, uint256 amount) private {
        userBalances[to] += amount;
        totalSupply += amount;
        emit MintPoints(to, amount);
    }

    /// @notice Burns points from a specified account's balance
    /// @dev Decrements `userBalances` and `totalSupply` by the given `amount`
    /// @param from The address from which points are to be burned
    /// @param amount The quantity of points to be burned
    function _burnPoints(address from, uint256 amount) private {
        userBalances[from] -= amount;
        totalSupply -= amount;
        emit BurnPoints(from, amount);
    }

    function _checkZero(uint256 amount) private pure {
        require(amount > 0, "is zero");
    }

    function _checkAmount(uint256 minimumSend) private {
        if (msg.value < minimumSend) {
            revert AmountOfEthSentIsTooSmall(msg.value, minimumSend);
        }
    }
}